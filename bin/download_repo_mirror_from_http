#!/bin/bash -eu

ARCHIVE_DESTINATION="/tmp/${BUILDKITE_PIPELINE_SLUG}.git.zip"
URL="${GIT_REFERENCE_REPO_HTTP_SERVER}"

latest_snapshot=""
get_latest_snapshot(){
  latest_snapshot=$( curl --retry 5 --retry-delay 5 $URL/s3/${GIT_REFERENCE_REPO_S3_BUCKET}/${BUILDKITE_ORGANIZATION_SLUG}/${BUILDKITE_PIPELINE_SLUG}/ -H "Accept: application/json" | jq -r '.[] | .name | select(endswith(".git.zip"))' | sort | tail -1 )
}

snapshot_not_found() {
  if [ -z "$latest_snapshot" ]; then
    echo "Latest Snapshot is empty"
    return 0
  fi

  return 1
}

echo "~~~ ðŸ“¦ Restoring cache for ${BUILDKITE_PIPELINE_SLUG} from http://${URL}"
get_latest_snapshot

# When using HTTP, we're referecing a mirror of an S3 bucket
if snapshot_not_found; then
  echo "No snapshots found â€“ skipping mirror download"
  exit 1 # Yes, we really want `exit` here â€“ we can't do much else here, so might as well abort the hook
fi

ARCHIVE_URL="http://${URL}/${BUILDKITE_ORGANIZATION_SLUG}/${BUILDKITE_PIPELINE_SLUG}/${latest_snapshot}"

# `curl` is doing a couple of really nice things for us here:
#
# - Use `-retry` to auto-retry the download if we're not successful the first time
# - Use `--time-cond` to automatically evaluate the destination file (if present) and avoid doing
#   the download at all if we already have the version of the file that's on the server (as determined
#   by the modification date).
curl --retry 5 "${ARCHIVE_URL}" --output "${ARCHIVE_DESTINATION}" --time-cond "${ARCHIVE_DESTINATION}"
echo "Download Complete"

echo "Unarchiving Git Repo at ${ARCHIVE_DESTINATION}"
unzip -o "${ARCHIVE_DESTINATION}" -d /tmp
echo "Unarchiving Complete"
