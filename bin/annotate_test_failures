#!/usr/bin/env ruby
#
# Usage:
#   annotate_test_failures [junit-file-path]
#
require 'rexml/document'
require 'shellwords'
require 'json'

###################
# Parse arguments
###################

junit_path = ARGV.first || File.join('build', 'results', 'report.junit')
title = ENV.fetch('BUILDKITE_LABEL', 'Tests')

unless File.exist?(junit_path)
  puts "JUnit file not found: #{junit_path}."
  # Don't fail if `.junit` file not found to avoid "hiding" the failure in the build that resulted in the that file not being created
  exit 0
end

###################
# Helper methods
###################

# Here's how report.junit XML files look like for failure vs success:
#
# <testcase classname='WordPressTest.MediaServiceTests' name='testDeletingLocalMediaThatDoesntExistInCoreData'>
#   <failure message='Asynchronous wait failed: Exceeded timeout of 0.1 seconds, with unfulfilled expectations: &quot;The delete call succeeds even if the media object isn&apos;t saved.&quot;.'>&lt;unknown&gt;:0</failure>
# </testcase>
# <testcase classname='WordPressTest.MediaServiceTests' name='testDeletingLocalMediaThatDoesntExistInCoreData' time='0.145'/>
#
class TestFailure
  attr_reader :classname, :name, :message, :details
  attr_accessor :count

  def initialize(node)
    @classname = node['classname']
    @name = node['name']
    failure_node = node.elements['failure']
    @message = failure_node['message']
    @details = failure_node.text
    @count = 1
  end

  def to_s
    times = @count > 1 ? " (#{@count} times)" : ''
    <<~ENTRY
      <details><summary><tt>#{@name}</tt> in <tt>#{@classname}</tt>#{times}</summary>
      #{@message}

      ```
      #{@details}
      ```
      </details>
    ENTRY
  end

  def key
    "#{@classname}.#{@name}"
  end

  def ultimately_succeeds?(parent_node:)
    all_same_test_nodes = parent_node.get_elements("testcase[@classname='#{@classname}' and @name='#{@name}']")
    !all_same_test_nodes.last.elements['failure'] # If last node found for that test doesn't have a <failure> child, then test ultimately succeeded.
  end

  def ==(other)
    @classname == other.classname && @name == other.name && @message == other.message && @details == other.details
  end
end

# Add a test_failure into a given array, or increment its count if it already exists
#
def record(test_failure, into:)
  existing = into.find { |f| f == test_failure }
  if existing.nil?
    into.append(test_failure)
  else
    existing.count += 1
  end
end

# Given a list of failures for a given step and state, update the corresponding annotation and return the list of failures in JSON
#
def update_annotation(title, list, style, state)
  annotation_context = "#{title} (#{state})"
  if list.empty?
    puts "No test #{state}. Removing any previous `#{annotation_context}` Buildkite annotation if any.\n\n"
    system("buildkite-agent annotation remove --context #{annotation_context.shellescape} 2>/dev/null || true")
  else
    tests_count = list.map(&:key).uniq.count # Count the number of tests that failed, even if some tests might have multiple assertion failures
    puts "#{tests_count} test(s) #{state} (#{list.count} distinct assertion failures in total). Reporting them as a `#{annotation_context}` Buildkite #{style} annotation.\n\n"
    markdown = "\#\#\#\# #{title}: #{tests_count} tests #{state} (#{list.count} distinct assertion failure(s) in total)\n\n" + list.map(&:to_s).join("\n")
    puts markdown
    assertion_failures_count = list.count

    # Only return JSON object for failing tests
    if state == 'have failed'
      tests = list.map do |item|
        {
          'name' => item.name,
          'classname' => item.classname,
          'message' => item.message,
          'details' => item.details
        }
      end

      test_failure_json_data = {
        'title' => title,
        'tests_count' => tests_count,
        'assertion_failures_count' => assertion_failures_count,
        'tests' => tests
      }
      return JSON.generate(test_failure_json_data)
    end
    system('buildkite-agent', 'annotate', markdown, '--style', style, '--context', annotation_context)
  end
end

###################
# Main
###################

file = File.open(junit_path)
xmldoc = REXML::Document.new(file)

failures = []
flakies = []
REXML::XPath.each(xmldoc, '//testcase[failure]') do |node|
  test_failure = TestFailure.new(node)

  if test_failure.ultimately_succeeds?(parent_node: node.parent)
    record(test_failure, into: flakies)
  else
    record(test_failure, into: failures)
  end
end

update_annotation(title, failures, 'error', 'have failed')
update_annotation(title, flakies, 'warning', 'were flaky')
