#!/usr/bin/env ruby
#
# Usage:
#   annotate_test_failures [junit-file-path]
#
require 'rexml/document'
require 'shellwords'
require 'net/http'
require 'json'

BUILDKITE_ORGANIZATION_SLUG = ENV.fetch('BUILDKITE_ORGANIZATION_SLUG')
BUILDKITE_PIPELINE_SLUG = ENV.fetch('BUILDKITE_PIPELINE_SLUG')
BUILDKITE_BUILD_NUMBER = ENV.fetch('BUILDKITE_BUILD_NUMBER')
BUILDKITE_BUILD_AUTHOR = ENV.fetch('BUILDKITE_BUILD_AUTHOR')
BUILDKITE_PIPELINE_NAME = ENV.fetch('BUILDKITE_PIPELINE_NAME')
BUILDKITE_JOB_ID = ENV.fetch('BUILDKITE_JOB_ID')
BUILDKITE_BRANCH = ENV.fetch('BUILDKITE_BRANCH')
SLACK_WEBHOOK = ENV.fetch('SLACK_WEBHOOK')

###################
# Parse arguments
###################

junit_path = ARGV.first || File.join('build', 'results', 'report.junit')
title = ENV.fetch('BUILDKITE_LABEL', 'Tests')

unless File.exist?(junit_path)
  puts "JUnit file not found: #{junit_path}."
  # Don't fail if `.junit` file not found to avoid "hiding" the failure in the build that resulted in the that file not being created
  exit 0
end

###################
# Helper methods
###################

# Here's how report.junit XML files look like for failure vs success:
#
# <testcase classname='WordPressTest.MediaServiceTests' name='testDeletingLocalMediaThatDoesntExistInCoreData'>
#   <failure message='Asynchronous wait failed: Exceeded timeout of 0.1 seconds, with unfulfilled expectations: &quot;The delete call succeeds even if the media object isn&apos;t saved.&quot;.'>&lt;unknown&gt;:0</failure>
# </testcase>
# <testcase classname="tests.test_editing_drafts.TestEditingDrafts" name="test_adding_a_photo_to_text_draft">
#   <error message="failed on setup with &quot;TypeError: list indices must be integers or slices, not str&quot;">Traceback (most recent call last): ...</error>
# </testcase>
# <testcase classname='WordPressTest.MediaServiceTests' name='testDeletingLocalMediaThatDoesntExistInCoreData' time='0.145'/>
#
class TestFailure
  attr_reader :classname, :name, :message, :details
  attr_accessor :count

  def initialize(node)
    @classname = node['classname']
    @name = node['name']
    failure_node = node.elements['failure'] || node.elements['error']
    @message = failure_node['message']
    @details = failure_node.text
    @count = 1
  end

  def to_s
    times = @count > 1 ? " (#{@count} times)" : ''
    <<~ENTRY
      <details><summary><tt>#{@name}</tt> in <tt>#{@classname}</tt>#{times}</summary>
      #{@message}

      ```
      #{@details}
      ```
      </details>
    ENTRY
  end

  def key
    "#{@classname}.#{@name}"
  end

  def ultimately_succeeds?(parent_node:)
    all_same_test_nodes = parent_node.get_elements("testcase[@classname='#{@classname}' and @name='#{@name}']")
    !(all_same_test_nodes.last.elements['failure'] || all_same_test_nodes.last.elements['error']) # If last node found for that test doesn't have a <failure> or <error> child, then test ultimately succeeded.
  end

  def ==(other)
    @classname == other.classname && @name == other.name && @message == other.message && @details == other.details
  end
end

# Add a test_failure into a given array, or increment its count if it already exists
#
def record(test_failure, into:)
  existing = into.find { |f| f == test_failure }
  if existing.nil?
    into.append(test_failure)
  else
    existing.count += 1
  end
end

# Given a list of failures for a given step and state, update the corresponding annotation and return the list of failures in JSON
#
def update_annotation(title, list, style, state)
  annotation_context = "#{title} (#{state})"
  if list.empty?
    puts "No test #{state}. Removing any previous `#{annotation_context}` Buildkite annotation if any.\n\n"
    system("buildkite-agent annotation remove --context #{annotation_context.shellescape} 2>/dev/null || true")
  else
    tests_count = list.map(&:key).uniq.count # Count the number of tests that failed, even if some tests might have multiple assertion failures
    puts "#{tests_count} test(s) #{state} (#{list.count} distinct assertion failures in total). Reporting them as a `#{annotation_context}` Buildkite #{style} annotation.\n\n"
    markdown = "\#\#\#\# #{title}: #{tests_count} tests #{state} (#{list.count} distinct assertion failure(s) in total)\n\n" + list.map(&:to_s).join("\n")
    puts markdown
    assertion_failures_count = list.count

    # Only return JSON object for failing tests
    if state == 'have failed'
      tests = list.map do |item|
        {
          'name' => item.name,
          'classname' => item.classname,
          'message' => item.message,
          'details' => item.details
        }
      end

      test_failure_json_data = {
        'title' => title,
        'tests_count' => tests_count,
        'assertion_failures_count' => assertion_failures_count,
        'tests' => tests
      }
      return JSON.generate(test_failure_json_data)
    end
    system('buildkite-agent', 'annotate', markdown, '--style', style, '--context', annotation_context)
  end
end

# Given a list of failing tests, send a slack notification with the test names in the payload
#
def send_slack_notification(title, failures)
  if failures==true # Don't send notification if there are no failures. The condition is set to check if failures equal true as system(...) returns true when no failures are found
    puts ":tada: All tests passed! Slack notification not sent."
  elsif "#{BUILDKITE_BRANCH}" != "trunk" # Don't send notification if build is not on trunk branch
    puts ":merged-pr: Failures not on trunk branch. Slack notification not sent."
  else
    data = JSON.parse(failures)
    failing_tests = data['tests'].map { |test| "#{test['name']} in #{test['classname']}" }
    assertion_failures_count = data['assertion_failures_count']

    slack_message_payload = {
      # testing channel - will be updated later
      "channel": "#jos-testing-notif",
      "username": "#{BUILDKITE_PIPELINE_NAME} Tests Failures",
      "icon_emoji": ":fire:",
      "blocks": [
        {
          "type": "section",
          "text": {
            "type": "mrkdwn",
            "text": ":warning: *#{assertion_failures_count} Test(s) Failed in #{BUILDKITE_PIPELINE_NAME} - #{title}*"
          },
          "accessory": {
            "type": "button",
            "text": {
              "type": "plain_text",
              "text": "Build",
              "emoji": true
            },
            "value": "build",
            "url": "https://buildkite.com/#{BUILDKITE_ORGANIZATION_SLUG}/#{BUILDKITE_PIPELINE_SLUG}/builds/#{BUILDKITE_BUILD_NUMBER}##{BUILDKITE_JOB_ID}",
            "action_id": "button-action"
          }
        },
        {
          "type": "divider"
        },
        {
          "type": "section",
          "text": {
            "type": "mrkdwn",
            "text": "*Failing Test(s):* #{failing_tests.to_s[1..-2]}\n" # To remove the bracket from the notification and only list the tests
          }
        }
      ]
    }

    json_payload = JSON.generate(slack_message_payload)

    # Send message to Slack
    uri = URI("#{SLACK_WEBHOOK}")
    response = Net::HTTP.post(uri, json_payload, "Content-Type" => "application/json")

    # Check response status
    if response.code == "200"
      puts ":slack: Notification Sent!"
    else
      puts ":slack: Failed to send notification. Response code: #{response.code}"
    end
  end
end

###################
# Main
###################

file = File.open(junit_path)
xmldoc = REXML::Document.new(file)

failures = []
flakies = []
REXML::XPath.each(xmldoc, '//testcase[failure|error]') do |node|
  test_failure = TestFailure.new(node)

  if test_failure.ultimately_succeeds?(parent_node: node.parent)
    record(test_failure, into: flakies)
  else
    record(test_failure, into: failures)
  end
end

json_failures = update_annotation(title, failures, 'error', 'have failed')
send_slack_notification(title, json_failures)
update_annotation(title, flakies, 'warning', 'were flaky')
