#!/usr/bin/env ruby
#
# Usage:
#   annotate_test_failures [junit-file-path]
#
require 'rexml/document'

junit_path = ARGV.first || File.join('build', 'results', 'report.junit')
title = ENV.fetch('BUILDKITE_LABEL', 'Tests')

unless File.exist?(junit_path)
  puts "JUnit file not found: #{junit_path}."
  # Don't fail if `.junit` file not found to avoid "hiding" the failure in the build that resulted in the that file not being created
  exit 0
end

file = File.open(junit_path)
xmldoc = REXML::Document.new(file)

# Here's how report.junit XML files look like for failure vs success:
#
# <testcase classname='WordPressTest.MediaServiceTests' name='testDeletingLocalMediaThatDoesntExistInCoreData'>
#   <failure message='Asynchronous wait failed: Exceeded timeout of 0.1 seconds, with unfulfilled expectations: &quot;The delete call succeeds even if the media object isn&apos;t saved.&quot;.'>&lt;unknown&gt;:0</failure>
# </testcase>
# <testcase classname='WordPressTest.MediaServiceTests' name='testDeletingLocalMediaThatDoesntExistInCoreData' time='0.145'/>
#
failures = []
REXML::XPath.each(xmldoc, '//testcase[failure]') do |testcase|
  test_class = testcase['classname']
  test_name = testcase['name']
  failure_node = testcase.elements['failure']
  failure_message = failure_node['message']

  # Find all nodes that are about the same test, to detect false positives
  # (in case there were multiple retries of the same flaky test with the last one ultimately passing)
  retries = testcase.parent.get_elements("testcase[@classname='#{testcase['classname']}' and @name='#{testcase['name']}']")
  if retries.last.elements['failure']
    failures.append <<~ENTRY
      <details><summary><tt>#{test_name}</tt> in <tt>#{test_class}</tt></summary>
      #{failure_message}
  
      ```
      #{failure_node.text}
      ```
      </details>
    ENTRY
  else
    puts "- Note: Flaky test \`#{test_class}`.`#{test_name}`: #{failure_message}"
  end
end

if failures.empty?
  puts "No test failure found (after eliminating intermediate failed retries). Removing any previous `#{title}` Buildkite annotation if any."
  system('buildkite-agent', 'annotation', 'remove', '--context', title)
  exit 0 # We don't want to fail if the `annotation remove` command failed because there was no previous annotation
else
  puts "Ultimately found #{failures.count} real test failure(s). Reporting them as a `#{title}` Buildkite annotation."
  markdown = "\#\#\#\# #{title}: #{failures.length} failure(s)\n\n" + failures.join("\n")
  puts markdown
  system('buildkite-agent', 'annotate', markdown, '--style', 'error', '--context', title)
  exit $?.exitstatus
end
